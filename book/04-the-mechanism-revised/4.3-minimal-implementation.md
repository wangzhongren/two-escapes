# 4.3 最小实现：动态分类的NumPy原型

以下代码用纯NumPy实现QKV机制，展示如何通过注意力协商临时类别。

```python
import numpy as np

def softmax(x):
    exp_x = np.exp(x - np.max(x, axis=-1, keepdims=True))
    return exp_x / np.sum(exp_x, axis=-1, keepdims=True)

class MinimalCategoryEngine:
    def __init__(self, d_model=64, n_categories=10):
        # 预定义响应语义库（模拟训练所得）
        self.response_bank = np.random.randn(n_categories, d_model)
        self.d_model = d_model
        
    def embed(self, tokens):
        """简单词嵌入：每个token映射到随机向量"""
        return np.random.randn(len(tokens), self.d_model)
    
    def forward(self, context_tokens, query_token):
        # 嵌入
        context_emb = self.embed(context_tokens)
        query_emb = self.embed([query_token])[0]
        
        # 投影到Q, K, V
        Wq = np.random.randn(self.d_model, self.d_model)
        Wk = np.random.randn(self.d_model, self.d_model)
        Wv = np.random.randn(self.d_model, self.d_model)
        
        Q = query_emb @ Wq  # (d,)
        K = context_emb @ Wk  # (n, d)
        V = context_emb @ Wv  # (n, d) — 实际中V应来自响应库
        
        # 动态原型构建
        scores = Q @ K.T / np.sqrt(self.d_model)  # (n,)
        weights = softmax(scores)
        output = weights @ V  # 加权响应
        
        return output, weights

# 示例：模拟“他”指代消解
engine = MinimalCategoryEngine()
context = ["张三", "告诉", "李四"]
query = "他"

output, attn_weights = engine.forward(context, query)
print(f"注意力权重: {attn_weights}")
print(f"生成响应向量维度: {output.shape}")
```

> 此最小模型虽无真实语义，但展示了**类别协商的计算本质**：Query通过Keys选择上下文中的原型，聚合其Values生成响应。

完整可运行实验见 `experiments/dynamic-categorization-minimal/`。